/**
 * Email Service
 * Handles email functionality using mailto: links and Web Share API
 * All processing happens client-side for privacy
 */

import { LogEntry, Goal, ValueItem, LCSWConfig } from '../types';

export interface EmailData {
  subject: string;
  body: string;
  attachments?: Array<{ name: string; content: string; type: string }>;
}

// Template cache for email generation
const emailTemplateCache = new Map<string, string>();

/**
 * Get cached template or generate and cache it
 */
function getCachedTemplate(key: string, generator: () => string): string {
  if (emailTemplateCache.has(key)) {
    return emailTemplateCache.get(key)!;
  }
  const template = generator();
  emailTemplateCache.set(key, template);
  return template;
}

/**
 * Check if Web Share API is available (mobile devices)
 */
export function isWebShareAvailable(): boolean {
  return typeof navigator !== 'undefined' && 'share' in navigator;
}

/**
 * Share content using Web Share API (mobile) or fallback to mailto:
 */
export async function shareViaEmail(
  emailData: EmailData,
  recipientEmails: string[] = []
): Promise<boolean> {
  try {
    // Try Web Share API first (mobile devices)
    if (isWebShareAvailable()) {
      const shareData: ShareData = {
        title: emailData.subject,
        text: emailData.body,
      };

      // Web Share API doesn't support email directly, but we can share the content
      // User can then choose to email it
      try {
        await navigator.share(shareData);
        return true;
      } catch (error: any) {
        // User cancelled or share failed, fallback to mailto
        if (error.name !== 'AbortError') {
          console.warn('Web Share failed, using mailto fallback:', error);
        }
      }
    }

    // Fallback to mailto: link
    return openMailtoLink(emailData, recipientEmails);
  } catch (error) {
    console.error('Email share error:', error);
    return false;
  }
}

/**
 * Open mailto: link with pre-filled email
 */
function openMailtoLink(emailData: EmailData, recipientEmails: string[]): boolean {
  try {
    const to = recipientEmails.length > 0 ? recipientEmails.join(',') : '';
    const subject = encodeURIComponent(emailData.subject);
    const body = encodeURIComponent(emailData.body);
    
    const mailtoLink = `mailto:${to}?subject=${subject}&body=${body}`;
    window.location.href = mailtoLink;
    return true;
  } catch (error) {
    console.error('Mailto link error:', error);
    return false;
  }
}

/**
 * Generate email report from logs
 */
export function generateEmailReport(
  logs: LogEntry[],
  values: ValueItem[],
  reportText?: string
): EmailData {
  const dateRange = logs.length > 0
    ? `${new Date(logs[logs.length - 1].date).toLocaleDateString()} - ${new Date(logs[0].date).toLocaleDateString()}`
    : 'No date range';

  const subject = `Grounded Therapy Integration Report - ${dateRange}`;

  let body = reportText || '';

  if (!body) {
    // Generate basic summary if no report text provided
    body = `Grounded by AC MiNDS - Therapy Integration Summary\n\n`;
    body += `Date Range: ${dateRange}\n`;
    body += `Total Entries: ${logs.length}\n\n`;
    
    if (logs.length > 0) {
      body += `Recent Activity:\n`;
      logs.slice(0, 10).forEach(log => {
        const value = values.find(v => v.id === log.valueId);
        let entry = `\n- ${new Date(log.date).toLocaleDateString()}: ${value?.name || 'General'}`;
        
        // Include deep reflection content
        if (log.deepReflection) {
          entry += `\n  Deep Reflection: ${log.deepReflection}`;
        }
        
        // Include committed action (goalText)
        if (log.goalText) {
          entry += `\n  Committed Action/Goal: ${log.goalText}`;
        }
        
        // Include suggested next steps (reflectionAnalysis)
        if (log.reflectionAnalysis) {
          entry += `\n  Suggested Next Steps: ${log.reflectionAnalysis}`;
        }
        
        // Include emotional state and feeling if available
        if (log.emotionalState) {
          entry += `\n  Emotional State: ${log.emotionalState}`;
          if (log.selectedFeeling) {
            entry += ` (${log.selectedFeeling})`;
          }
        }
        
        // Include note as fallback if no deep reflection
        if (log.note && !log.deepReflection) {
          entry += `\n  Note: ${log.note}`;
        }
        
        entry += '\n';
        body += entry;
      });
    }
  }

  body += `\n\n---\n`;
  body += `This report was generated by Grounded by AC MiNDS, a privacy-first therapy integration app.\n`;
  body += `All data processing happens on-device. This report is for sharing with your LCSW.\n`;

  return { subject, body };
}

/**
 * Generate email summary of goals and updates
 * Includes detailed progress updates for therapist review
 */
export function generateGoalsEmail(
  goals: Goal[],
  values: ValueItem[],
  completedGoals: Goal[],
  includeUpdates: boolean = true
): EmailData {
  const dateStr = new Date().toLocaleDateString();
  const subject = `Grounded Goals Update - ${dateStr}`;

  // Use cached template header
  const headerTemplate = getCachedTemplate('goals_email_header', () => 
    `Grounded by AC MiNDS - Goals & Progress Update\n\n`
  );

  let body = headerTemplate;
  body += `Date: ${dateStr}\n\n`;

  if (completedGoals.length > 0) {
    body += `âœ… Completed Goals:\n`;
    completedGoals.forEach(goal => {
      const value = values.find(v => v.id === goal.valueId);
      body += `\n- ${value?.name || 'General'}: ${goal.text}\n`;
      if (goal.updates.length > 0 && includeUpdates) {
        body += `  Progress Updates:\n`;
        goal.updates.forEach(update => {
          body += `    â€¢ ${new Date(update.timestamp).toLocaleDateString()}${update.mood ? ` ${update.mood}` : ''}: ${update.note}\n`;
        });
      } else if (goal.updates.length > 0) {
        body += `  Total Updates: ${goal.updates.length}\n`;
      }
    });
    body += `\n`;
  }

  const activeGoals = goals.filter(g => !g.completed);
  if (activeGoals.length > 0) {
    body += `ðŸ“‹ Active Goals & Progress:\n`;
    activeGoals.forEach(goal => {
      const value = values.find(v => v.id === goal.valueId);
      body += `\n- ${value?.name || 'General'}: ${goal.text}\n`;
      body += `  Frequency: ${goal.frequency}\n`;
      
      if (goal.updates.length > 0) {
        if (includeUpdates) {
          body += `  Recent Progress Updates:\n`;
          // Show last 5 updates, most recent first
          goal.updates.slice().reverse().slice(0, 5).forEach(update => {
            body += `    â€¢ ${new Date(update.timestamp).toLocaleDateString()}${update.mood ? ` ${update.mood}` : ''}: ${update.note}\n`;
          });
          if (goal.updates.length > 5) {
            body += `    ... and ${goal.updates.length - 5} more update(s)\n`;
          }
        } else {
          body += `  Total Updates: ${goal.updates.length}\n`;
        }
      } else {
        body += `  No updates yet\n`;
      }
    });
  }

  body += `\n\n---\n`;
  body += `This update was generated by Grounded by AC MiNDS.\n`;
  body += `Regular progress updates help track growth and inform therapy sessions.\n`;

  return { subject, body };
}

/**
 * Generate comprehensive data export email
 */
export function generateDataExportEmail(
  logs: LogEntry[],
  goals: Goal[],
  values: ValueItem[],
  settings: any
): EmailData {
  const subject = `Grounded Complete Data Export - ${new Date().toLocaleDateString()}`;

  let body = `Grounded by AC MiNDS - Complete Data Export\n\n`;
  body += `Export Date: ${new Date().toISOString()}\n`;
  body += `Total Logs: ${logs.length}\n`;
  body += `Total Goals: ${goals.length}\n`;
  body += `Active Values: ${values.length}\n\n`;

  body += `=== LOGS ===\n\n`;
  if (logs.length === 0) {
    body += `No logs recorded.\n\n`;
  } else {
    logs.forEach(log => {
      const value = values.find(v => v.id === log.valueId);
      body += `[${new Date(log.date).toLocaleDateString()}] ${value?.name || 'General'}\n`;
      body += `Mood: ${log.mood || 'N/A'}\n`;
      body += `Note: ${log.note}\n`;
      if (log.goalText) {
        body += `Related Goal: ${log.goalText}\n`;
      }
      body += `\n`;
    });
  }

  body += `=== GOALS ===\n\n`;
  if (goals.length === 0) {
    body += `No goals set.\n\n`;
  } else {
    goals.forEach(goal => {
      const value = values.find(v => v.id === goal.valueId);
      body += `${goal.completed ? 'âœ…' : 'ðŸ“‹'} ${value?.name || 'General'}\n`;
      body += `Goal: ${goal.text}\n`;
      body += `Frequency: ${goal.frequency}\n`;
      body += `Created: ${new Date(goal.createdAt).toLocaleDateString()}\n`;
      if (goal.updates.length > 0) {
        body += `Updates:\n`;
        goal.updates.forEach(update => {
          body += `  - ${new Date(update.timestamp).toLocaleDateString()}: ${update.note}\n`;
        });
      }
      body += `\n`;
    });
  }

  body += `\n---\n`;
  body += `This export contains all your Grounded data.\n`;
  body += `Keep this email secure and only share with trusted healthcare providers.\n`;

  return { subject, body };
}

/**
 * Schedule email summary (stores schedule locally)
 */
export interface EmailSchedule {
  enabled: boolean;
  frequency: 'daily' | 'weekly' | 'monthly';
  time: string; // HH:mm format
  recipientEmails: string[];
  lastSent?: string;
}

export function saveEmailSchedule(userId: string, schedule: EmailSchedule): void {
  localStorage.setItem(`emailSchedule_${userId}`, JSON.stringify(schedule));
}

export function getEmailSchedule(userId: string): EmailSchedule | null {
  const stored = localStorage.getItem(`emailSchedule_${userId}`);
  return stored ? JSON.parse(stored) : null;
}

/**
 * Check if it's time to send scheduled email
 */
export function shouldSendScheduledEmail(schedule: EmailSchedule): boolean {
  if (!schedule.enabled) return false;

  const now = new Date();
  const lastSent = schedule.lastSent ? new Date(schedule.lastSent) : null;
  const [scheduleHour, scheduleMin] = schedule.time.split(':').map(Number);
  const currentHour = now.getHours();
  const currentMin = now.getMinutes();

  // Check if current time matches scheduled time
  if (currentHour !== scheduleHour || currentMin !== scheduleMin) {
    return false;
  }

  // Check frequency
  if (!lastSent) return true; // Never sent, send now

  const daysSinceLastSent = Math.floor((now.getTime() - lastSent.getTime()) / (1000 * 60 * 60 * 24));

  switch (schedule.frequency) {
    case 'daily':
      return daysSinceLastSent >= 1;
    case 'weekly':
      return daysSinceLastSent >= 7;
    case 'monthly':
      return daysSinceLastSent >= 30;
    default:
      return false;
  }
}
